package giesing.karl.android.widgets;

/**
 * This is a class that holds static final objects that implement various response
 * curves.
 * @author Karl Giesing
 * @see ResponseCurve
 */
public class ResponseCurves {
	/**
	 * Implements a linear response curve.
	 */
	public static final ResponseCurve LINEAR = new ResponseCurve() {
		
		@Override
		public float toScale(float curve) {
			return curve;
		}
		
		@Override
		public float toCurve(float scale) {
			return scale;
		}
	};
	
	/**
	 * Implements an audio response curve, similar to a logarithmic taper in an
	 * analog potentiometer.
	 * <p>
	 * The response curve simulates a signal-to-noise (S/N) ratio of 96dB (the
	 * S/N ratio of 16-bit audio, e.g. a CD). This is actually a larger S/N
	 * ratio than most analog equipment can reproduce, so this curve should be
	 * sufficient for any real-world application.
	 * 
	 * @see <a
	 *      href="http://www.dr-lex.be/info-stuff/volumecontrols.html">Programming
	 *      Volume Controls</a> by Alexander Thomas
	 */
	public static final ResponseCurve AUDIO_LOG = new ResponseCurve() {
		private final float ampl = (float) Math.pow(10.0, 96.0 / 20.0);
		private final float b = (float) Math.log(ampl);
		
		@Override
		public float toScale(float curve) {
			return (float) (Math.log(ampl * curve) / b);
		}
		
		@Override
		public float toCurve(float scale) {
			return (float) (Math.exp(b * scale) / ampl);
		}
	};
	
	/**
	 * Models an audio response curve, using the formula
	 * <code>y = x^(96/10)</code>, where 96dB = S/N ratio of 16-bit audio. This
	 * is actually a larger S/N ratio than most analog equipment can reproduce,
	 * so this curve should be sufficient for any real-world application.
	 * <p>
	 * This is computationally cheaper than AUDIO_LOG, and results in a loudness
	 * curve that is almost indistinguishable.
	 */
	public static final ResponseCurve AUDIO = new ResponseCurve() {
		
		@Override
		public float toScale(float curve) {
			// 9.6'th root of y
			return (float) Math.pow(curve, 1.0 / 9.6);
		}
		
		@Override
		public float toCurve(float scale) {
			return (float) Math.pow(scale, 9.6);
		}
	};
	
	/**
	 * Implements an audio frequency response curve. Assumes that the scale
	 * interval of 0.0f to 1.0f represents one octave.
	 * <p>
	 * To convert the interval to musical frequencies, use this formula:
	 * <blockquote><code>fq = (v * root * curve) + root;</code></blockquote>
	 * ...where:
	 * <ul>
	 * <li><code>fq</code> = note frequency</li>
	 * <li><code>v</code> = number of octaves</li>
	 * <li><code>root</code> = root frequency (frequency of the lowest note,
	 * e.g. 440Hz for A4)</li>
	 * <li><code>curve</code> = value returned from the toCurve method</li>
	 * </ul>
	 * For example, if your linear scale value is generated by a one-octave
	 * keyboard going from A4 to A5, then the Java code to get the frequency
	 * would be:
	 * <blockquote>
	 * <code>float fq = 440.0f * toCurve(scale) + 440.0f;</code>
	 * </blockquote>
	 * You can use the same formula for other audio components as well (e.g. the
	 * cutoff frequency of a low-pass filter).
	 */
	public static final ResponseCurve FREQUENCY = new ResponseCurve() {
		
		@Override
		public float toScale(float curve) {
			return (float) (Math.log1p(curve) / Math.log(2));
		}
		
		@Override
		public float toCurve(float scale) {
			return (float) (Math.pow(2.0, scale) - 1.0);
		}
	};

}
